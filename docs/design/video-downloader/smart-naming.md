# Smart Naming ä»•æ§˜æ›¸

## 1. æ¦‚è¦

Smart Namingã¯ã€ãƒ€ã‚¦ãƒ³ãƒ­ãƒ¼ãƒ‰ã™ã‚‹å‹•ç”»ãƒ•ã‚¡ã‚¤ãƒ«ã«å¯¾ã—ã¦ã€ãƒšãƒ¼ã‚¸ã®ã‚³ãƒ³ãƒ†ã‚­ã‚¹ãƒˆã‹ã‚‰è‡ªå‹•çš„ã«æ„å‘³ã®ã‚ã‚‹ãƒ•ã‚¡ã‚¤ãƒ«åã‚’ç”Ÿæˆã™ã‚‹æ©Ÿèƒ½ã§ã™ã€‚ãƒ¦ãƒ¼ã‚¶ãƒ¼ãŒå®šç¾©ã—ãŸãƒ†ãƒ³ãƒ—ãƒ¬ãƒ¼ãƒˆã«åŸºã¥ã„ã¦ã€å‹•çš„ã«ãƒˆãƒ¼ã‚¯ãƒ³ã‚’æŠ½å‡ºãƒ»ç½®æ›ã—ã¾ã™ã€‚

## 2. ã‚¢ãƒ¼ã‚­ãƒ†ã‚¯ãƒãƒ£

```
â”Œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”
â”‚                  WebView (Browser)                   â”‚
â”‚  â”Œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”   â”‚
â”‚  â”‚         DOM Content (HTML/Metadata)          â”‚   â”‚
â”‚  â””â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”˜   â”‚
â””â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”˜
                           â†“
                   DOMæƒ…å ±ã®æŠ½å‡º
                           â†“
â”Œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”
â”‚               Preload Script                         â”‚
â”‚  â”Œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”   â”‚
â”‚  â”‚          Token Extractor                     â”‚   â”‚
â”‚  â”‚  - CSS Selector ã«ã‚ˆã‚‹æŠ½å‡º                    â”‚   â”‚
â”‚  â”‚  - æ­£è¦è¡¨ç¾ã«ã‚ˆã‚‹æŠ½å‡º                         â”‚   â”‚
â”‚  â”‚  - ãƒ¡ã‚¿ãƒ‡ãƒ¼ã‚¿è§£æ                            â”‚   â”‚
â”‚  â””â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”˜   â”‚
â””â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”˜
                           â†“
                    IPCçµŒç”±ã§é€ä¿¡
                           â†“
â”Œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”
â”‚                  Main Process                        â”‚
â”‚  â”Œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”   â”‚
â”‚  â”‚         Smart Naming Engine                  â”‚   â”‚
â”‚  â”‚  - ãƒ†ãƒ³ãƒ—ãƒ¬ãƒ¼ãƒˆå‡¦ç†                          â”‚   â”‚
â”‚  â”‚  - ãƒˆãƒ¼ã‚¯ãƒ³ç½®æ›                              â”‚   â”‚
â”‚  â”‚  - ã‚µãƒ‹ã‚¿ã‚¤ã‚¼ãƒ¼ã‚·ãƒ§ãƒ³                        â”‚   â”‚
â”‚  â”‚  - é‡è¤‡å›é¿                                  â”‚   â”‚
â”‚  â””â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”˜   â”‚
â””â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”˜
                           â†“
                    æœ€çµ‚ãƒ•ã‚¡ã‚¤ãƒ«å
```

## 3. ãƒˆãƒ¼ã‚¯ãƒ³ã‚·ã‚¹ãƒ†ãƒ 

### 3.1 æ¨™æº–ãƒˆãƒ¼ã‚¯ãƒ³

| ãƒˆãƒ¼ã‚¯ãƒ³ | èª¬æ˜ | æŠ½å‡ºå…ƒ | ãƒ•ã‚©ãƒ¼ãƒ«ãƒãƒƒã‚¯ |
|---------|------|--------|---------------|
| `{title}` | ãƒšãƒ¼ã‚¸/å‹•ç”»ã‚¿ã‚¤ãƒˆãƒ« | `<title>`, `og:title`, h1 | "video" |
| `{site}` | ã‚µã‚¤ãƒˆå | ãƒ‰ãƒ¡ã‚¤ãƒ³å, `og:site_name` | ãƒ‰ãƒ¡ã‚¤ãƒ³ |
| `{channel}` | ãƒãƒ£ãƒ³ãƒãƒ«/æŠ•ç¨¿è€…å | ã‚µã‚¤ãƒˆå›ºæœ‰ã‚»ãƒ¬ã‚¯ã‚¿ | "unknown" |
| `{episode}` | ã‚¨ãƒ”ã‚½ãƒ¼ãƒ‰ç•ªå· | æ­£è¦è¡¨ç¾æŠ½å‡º | "" |
| `{season}` | ã‚·ãƒ¼ã‚ºãƒ³ç•ªå· | æ­£è¦è¡¨ç¾æŠ½å‡º | "" |
| `{quality}` | å‹•ç”»å“è³ª | é¸æŠã•ã‚ŒãŸvariant | "default" |
| `{resolution}` | è§£åƒåº¦ | variantæƒ…å ± | "" |
| `{date}` | ç¾åœ¨æ—¥ä»˜ | ã‚·ã‚¹ãƒ†ãƒ æ—¥æ™‚ | YYYY-MM-DD |
| `{time}` | ç¾åœ¨æ™‚åˆ» | ã‚·ã‚¹ãƒ†ãƒ æ™‚åˆ» | HH-MM-SS |
| `{year}` | å¹´ | ã‚·ã‚¹ãƒ†ãƒ æ—¥æ™‚ | YYYY |
| `{month}` | æœˆ | ã‚·ã‚¹ãƒ†ãƒ æ—¥æ™‚ | MM |
| `{day}` | æ—¥ | ã‚·ã‚¹ãƒ†ãƒ æ—¥æ™‚ | DD |
| `{timestamp}` | UNIXã‚¿ã‚¤ãƒ ã‚¹ã‚¿ãƒ³ãƒ— | ã‚·ã‚¹ãƒ†ãƒ æ™‚åˆ» | æ•°å€¤ |
| `{uuid}` | ãƒ¦ãƒ‹ãƒ¼ã‚¯ID | UUID v4 | ãƒ©ãƒ³ãƒ€ãƒ  |
| `{index}` | é€£ç•ª | è‡ªå‹•ã‚¤ãƒ³ã‚¯ãƒªãƒ¡ãƒ³ãƒˆ | æ•°å€¤ |

### 3.2 ã‚«ã‚¹ã‚¿ãƒ ãƒˆãƒ¼ã‚¯ãƒ³

ãƒ¦ãƒ¼ã‚¶ãƒ¼ãŒã‚µã‚¤ãƒˆã”ã¨ã«ç‹¬è‡ªã®ãƒˆãƒ¼ã‚¯ãƒ³ã‚’å®šç¾©å¯èƒ½ï¼š

```typescript
interface CustomToken {
  name: string;           // ãƒˆãƒ¼ã‚¯ãƒ³åï¼ˆ{custom_name}ï¼‰
  sitePattern: string;    // é©ç”¨ã‚µã‚¤ãƒˆãƒ‘ã‚¿ãƒ¼ãƒ³ï¼ˆæ­£è¦è¡¨ç¾ï¼‰
  extractors: TokenExtractor[];  // æŠ½å‡ºæ–¹æ³•ã®ãƒªã‚¹ãƒˆï¼ˆå„ªå…ˆé †ï¼‰
  fallback?: string;      // ãƒ‡ãƒ•ã‚©ãƒ«ãƒˆå€¤
  transform?: TokenTransform[];  // å¤‰æ›å‡¦ç†
}

interface TokenExtractor {
  type: 'selector' | 'regex' | 'meta' | 'jsonld' | 'attribute';
  value: string;          // ã‚»ãƒ¬ã‚¯ã‚¿ or æ­£è¦è¡¨ç¾
  attribute?: string;     // å±æ€§åï¼ˆtype='attribute'ã®å ´åˆï¼‰
  group?: number;         // æ­£è¦è¡¨ç¾ã‚°ãƒ«ãƒ¼ãƒ—ç•ªå·
}

interface TokenTransform {
  type: 'replace' | 'lowercase' | 'uppercase' | 'trim' | 'truncate' | 'sanitize';
  value?: string;         // å¤‰æ›ãƒ‘ãƒ©ãƒ¡ãƒ¼ã‚¿
}
```

## 4. ãƒˆãƒ¼ã‚¯ãƒ³æŠ½å‡ºå®Ÿè£…

### 4.1 Preload Scriptï¼ˆDOMæŠ½å‡ºï¼‰

```typescript
// preload/token-extractor.ts
class TokenExtractor {
  private tokens: Map<string, string> = new Map();
  
  extractAll(): Record<string, string> {
    this.extractBasicTokens();
    this.extractMetaTags();
    this.extractStructuredData();
    this.extractCustomTokens();
    
    return Object.fromEntries(this.tokens);
  }
  
  private extractBasicTokens(): void {
    // ã‚¿ã‚¤ãƒˆãƒ«
    const title = this.extractTitle();
    if (title) this.tokens.set('title', title);
    
    // ã‚µã‚¤ãƒˆå
    const site = this.extractSiteName();
    if (site) this.tokens.set('site', site);
    
    // URLé–¢é€£
    const url = new URL(window.location.href);
    this.tokens.set('domain', url.hostname);
    this.tokens.set('path', url.pathname);
  }
  
  private extractTitle(): string | null {
    // å„ªå…ˆé †ä½ä»˜ãã§æŠ½å‡º
    const strategies = [
      () => document.querySelector('meta[property="og:title"]')?.getAttribute('content'),
      () => document.querySelector('meta[name="twitter:title"]')?.getAttribute('content'),
      () => document.querySelector('h1')?.textContent?.trim(),
      () => document.title,
    ];
    
    for (const strategy of strategies) {
      const result = strategy();
      if (result) return this.sanitizeText(result);
    }
    
    return null;
  }
  
  private extractSiteName(): string | null {
    const strategies = [
      () => document.querySelector('meta[property="og:site_name"]')?.getAttribute('content'),
      () => document.querySelector('meta[name="application-name"]')?.getAttribute('content'),
      () => window.location.hostname.replace('www.', '').split('.')[0],
    ];
    
    for (const strategy of strategies) {
      const result = strategy();
      if (result) return this.sanitizeText(result);
    }
    
    return null;
  }
  
  private extractMetaTags(): void {
    // Open Graph
    const ogTags = ['description', 'image', 'video', 'audio', 'type'];
    ogTags.forEach(tag => {
      const content = document.querySelector(`meta[property="og:${tag}"]`)?.getAttribute('content');
      if (content) this.tokens.set(`og_${tag}`, content);
    });
    
    // Twitter Card
    const twitterTags = ['creator', 'site', 'description'];
    twitterTags.forEach(tag => {
      const content = document.querySelector(`meta[name="twitter:${tag}"]`)?.getAttribute('content');
      if (content) this.tokens.set(`twitter_${tag}`, content);
    });
  }
  
  private extractStructuredData(): void {
    // JSON-LD
    const jsonLdScripts = document.querySelectorAll('script[type="application/ld+json"]');
    jsonLdScripts.forEach(script => {
      try {
        const data = JSON.parse(script.textContent || '{}');
        this.processStructuredData(data);
      } catch (e) {
        console.warn('Failed to parse JSON-LD:', e);
      }
    });
  }
  
  private processStructuredData(data: any, prefix = ''): void {
    if (data['@type'] === 'VideoObject') {
      if (data.name) this.tokens.set('video_name', data.name);
      if (data.description) this.tokens.set('video_description', data.description);
      if (data.duration) this.tokens.set('video_duration', data.duration);
      if (data.uploadDate) this.tokens.set('video_upload_date', data.uploadDate);
      if (data.creator?.name) this.tokens.set('creator', data.creator.name);
    }
    
    if (data['@type'] === 'BreadcrumbList' && data.itemListElement) {
      const breadcrumbs = data.itemListElement
        .map((item: any) => item.name)
        .filter(Boolean)
        .join('_');
      if (breadcrumbs) this.tokens.set('breadcrumb', breadcrumbs);
    }
  }
  
  private extractCustomTokens(): void {
    // ã‚µã‚¤ãƒˆå›ºæœ‰ã®æŠ½å‡ºãƒ«ãƒ¼ãƒ«
    const siteRules = this.getSiteSpecificRules();
    
    siteRules.forEach(rule => {
      if (rule.urlPattern.test(window.location.href)) {
        rule.tokens.forEach(tokenDef => {
          const value = this.extractByRule(tokenDef);
          if (value) this.tokens.set(tokenDef.name, value);
        });
      }
    });
  }
  
  private getSiteSpecificRules(): SiteRule[] {
    return [
      {
        urlPattern: /youtube\.com/,
        tokens: [
          {
            name: 'channel',
            selector: 'ytd-channel-name a',
            attribute: 'textContent'
          },
          {
            name: 'views',
            selector: '.view-count',
            regex: /([0-9,]+)/,
            group: 1
          }
        ]
      },
      {
        urlPattern: /vimeo\.com/,
        tokens: [
          {
            name: 'channel',
            selector: '.byline a',
            attribute: 'textContent'
          }
        ]
      },
      // ä»–ã®ã‚µã‚¤ãƒˆãƒ«ãƒ¼ãƒ«...
    ];
  }
  
  private extractByRule(rule: TokenDefinition): string | null {
    if (rule.selector) {
      const element = document.querySelector(rule.selector);
      if (element) {
        let value = rule.attribute 
          ? element.getAttribute(rule.attribute) || element.textContent
          : element.textContent;
          
        if (value && rule.regex) {
          const match = value.match(new RegExp(rule.regex));
          value = match?.[rule.group || 0] || null;
        }
        
        return value ? this.sanitizeText(value) : null;
      }
    }
    
    return null;
  }
  
  private sanitizeText(text: string): string {
    return text
      .trim()
      .replace(/\s+/g, ' ')           // è¤‡æ•°ã‚¹ãƒšãƒ¼ã‚¹ã‚’å˜ä¸€ã«
      .replace(/[<>:"/\\|?*]/g, '_')  // ãƒ•ã‚¡ã‚¤ãƒ«åç¦æ­¢æ–‡å­—ã‚’ç½®æ›
      .substring(0, 100);              // é•·ã•åˆ¶é™
  }
}
```

### 4.2 Main Processï¼ˆãƒ†ãƒ³ãƒ—ãƒ¬ãƒ¼ãƒˆå‡¦ç†ï¼‰

```typescript
// main/smart-naming-engine.ts
import { format } from 'date-fns';

class SmartNamingEngine {
  private db: Database;
  private defaultTemplate = '{site}-{title}-{quality}-{date}';
  
  async generateFileName(
    template: string,
    tokens: Record<string, string>,
    context: DownloadContext
  ): Promise<string> {
    // ãƒ¦ãƒ¼ã‚¶ãƒ¼å®šç¾©ãƒ†ãƒ³ãƒ—ãƒ¬ãƒ¼ãƒˆã¾ãŸã¯ãƒ‡ãƒ•ã‚©ãƒ«ãƒˆ
    const finalTemplate = template || this.defaultTemplate;
    
    // ã‚³ãƒ³ãƒ†ã‚­ã‚¹ãƒˆã‹ã‚‰ãƒˆãƒ¼ã‚¯ãƒ³ã‚’è¿½åŠ 
    const allTokens = {
      ...tokens,
      ...this.getContextTokens(context),
      ...this.getSystemTokens(),
    };
    
    // ãƒ†ãƒ³ãƒ—ãƒ¬ãƒ¼ãƒˆå‡¦ç†
    let filename = this.processTemplate(finalTemplate, allTokens);
    
    // ã‚µãƒ‹ã‚¿ã‚¤ã‚¼ãƒ¼ã‚·ãƒ§ãƒ³
    filename = this.sanitizeFileName(filename);
    
    // é‡è¤‡å›é¿
    filename = await this.ensureUnique(filename, context.saveDir);
    
    return filename;
  }
  
  private getContextTokens(context: DownloadContext): Record<string, string> {
    const tokens: Record<string, string> = {};
    
    if (context.variant) {
      tokens.quality = context.variant.label || context.variant.resolution || 'default';
      tokens.resolution = context.variant.resolution || '';
      tokens.bitrate = context.variant.bandwidth?.toString() || '';
      tokens.codec = context.variant.codecs || '';
    }
    
    if (context.mediaType) {
      tokens.type = context.mediaType;
    }
    
    return tokens;
  }
  
  private getSystemTokens(): Record<string, string> {
    const now = new Date();
    
    return {
      date: format(now, 'yyyy-MM-dd'),
      time: format(now, 'HH-mm-ss'),
      year: format(now, 'yyyy'),
      month: format(now, 'MM'),
      day: format(now, 'dd'),
      timestamp: now.getTime().toString(),
      uuid: uuidv4().substring(0, 8),
    };
  }
  
  private processTemplate(template: string, tokens: Record<string, string>): string {
    // æ¡ä»¶ä»˜ãã‚»ã‚¯ã‚·ãƒ§ãƒ³å‡¦ç†
    // {?quality:{quality}_}? â†’ qualityãŒå­˜åœ¨ã™ã‚‹å ´åˆã®ã¿å±•é–‹
    template = template.replace(
      /\{\?(\w+):([^}]*)\}\?/g,
      (match, tokenName, content) => {
        if (tokens[tokenName]) {
          return content.replace(`{${tokenName}}`, tokens[tokenName]);
        }
        return '';
      }
    );
    
    // é€šå¸¸ã®ãƒˆãƒ¼ã‚¯ãƒ³ç½®æ›
    let result = template;
    Object.entries(tokens).forEach(([key, value]) => {
      const regex = new RegExp(`\\{${key}\\}`, 'g');
      result = result.replace(regex, value || '');
    });
    
    // æœªç½®æ›ãƒˆãƒ¼ã‚¯ãƒ³ã®å‡¦ç†
    result = result.replace(/\{[^}]+\}/g, '');
    
    // é€£ç¶šã™ã‚‹åŒºåˆ‡ã‚Šæ–‡å­—ã®å‰Šæ¸›
    result = result.replace(/[-_]{2,}/g, '_');
    result = result.replace(/^[-_]+|[-_]+$/g, '');
    
    return result;
  }
  
  private sanitizeFileName(filename: string): string {
    // OSäºˆç´„æ–‡å­—ã®ç½®æ›
    const reserved = /[<>:"/\\|?*\x00-\x1F]/g;
    filename = filename.replace(reserved, '_');
    
    // Windowsäºˆç´„åã®å›é¿
    const windowsReserved = /^(CON|PRN|AUX|NUL|COM[1-9]|LPT[1-9])$/i;
    if (windowsReserved.test(filename)) {
      filename = `_${filename}`;
    }
    
    // ç©ºç™½ã®æ­£è¦åŒ–
    filename = filename.replace(/\s+/g, '_');
    
    // é•·ã•åˆ¶é™ï¼ˆæ‹¡å¼µå­ã‚’è€ƒæ…®ï¼‰
    const maxLength = 200; // å®‰å…¨ãƒãƒ¼ã‚¸ãƒ³ã‚’æŒãŸã›ã‚‹
    if (filename.length > maxLength) {
      filename = filename.substring(0, maxLength);
    }
    
    // å…ˆé ­ãƒ»æœ«å°¾ã®å‡¦ç†
    filename = filename.replace(/^\.+/, ''); // å…ˆé ­ã®ãƒ‰ãƒƒãƒˆå‰Šé™¤
    filename = filename.replace(/\.+$/, ''); // æœ«å°¾ã®ãƒ‰ãƒƒãƒˆå‰Šé™¤
    
    return filename || 'download';
  }
  
  private async ensureUnique(filename: string, saveDir: string): Promise<string> {
    const ext = path.extname(filename);
    const base = path.basename(filename, ext);
    
    let counter = 0;
    let finalName = filename;
    
    while (await this.fileExists(path.join(saveDir, finalName))) {
      counter++;
      finalName = `${base}_${counter}${ext}`;
      
      if (counter > 999) {
        // ç„¡é™ãƒ«ãƒ¼ãƒ—é˜²æ­¢
        finalName = `${base}_${Date.now()}${ext}`;
        break;
      }
    }
    
    return finalName;
  }
  
  private async fileExists(filePath: string): Promise<boolean> {
    try {
      await fs.access(filePath);
      return true;
    } catch {
      return false;
    }
  }
}
```

## 5. UIå®Ÿè£…

### 5.1 ãƒ†ãƒ³ãƒ—ãƒ¬ãƒ¼ãƒˆç·¨é›†ç”»é¢

```typescript
// renderer/components/SmartNamingConfig.tsx
import React, { useState, useEffect } from 'react';

interface SmartNamingConfigProps {
  onSave: (template: string, rules: CustomTokenRule[]) => void;
}

export const SmartNamingConfig: React.FC<SmartNamingConfigProps> = ({ onSave }) => {
  const [template, setTemplate] = useState('{site}-{title}-{quality}-{date}');
  const [preview, setPreview] = useState('');
  const [availableTokens, setAvailableTokens] = useState<Token[]>([]);
  const [customRules, setCustomRules] = useState<CustomTokenRule[]>([]);
  
  // ãƒªã‚¢ãƒ«ã‚¿ã‚¤ãƒ ãƒ—ãƒ¬ãƒ“ãƒ¥ãƒ¼
  useEffect(() => {
    updatePreview();
  }, [template]);
  
  const updatePreview = async () => {
    const sampleTokens = {
      site: 'youtube',
      title: 'Sample_Video_Title',
      quality: '1080p',
      date: '2024-01-15',
      channel: 'SampleChannel',
    };
    
    const result = await window.electronAPI.naming.preview(template, sampleTokens);
    setPreview(result);
  };
  
  const handleTokenClick = (token: string) => {
    const cursorPos = inputRef.current?.selectionStart || template.length;
    const newTemplate = 
      template.slice(0, cursorPos) + 
      `{${token}}` + 
      template.slice(cursorPos);
    setTemplate(newTemplate);
  };
  
  const handleAddCustomRule = () => {
    setCustomRules([
      ...customRules,
      {
        id: Date.now().toString(),
        name: '',
        sitePattern: '',
        selector: '',
        enabled: true,
      }
    ]);
  };
  
  return (
    <div className="smart-naming-config">
      <div className="template-section">
        <h3>ãƒ•ã‚¡ã‚¤ãƒ«åãƒ†ãƒ³ãƒ—ãƒ¬ãƒ¼ãƒˆ</h3>
        <div className="template-input">
          <input
            ref={inputRef}
            type="text"
            value={template}
            onChange={(e) => setTemplate(e.target.value)}
            placeholder="ãƒ•ã‚¡ã‚¤ãƒ«åãƒ†ãƒ³ãƒ—ãƒ¬ãƒ¼ãƒˆã‚’å…¥åŠ›"
          />
          <button onClick={() => setTemplate('{site}-{title}-{quality}-{date}')}>
            ãƒ‡ãƒ•ã‚©ãƒ«ãƒˆã«æˆ»ã™
          </button>
        </div>
        
        <div className="token-palette">
          <h4>åˆ©ç”¨å¯èƒ½ãªãƒˆãƒ¼ã‚¯ãƒ³</h4>
          <div className="token-grid">
            {availableTokens.map(token => (
              <button
                key={token.name}
                className="token-button"
                onClick={() => handleTokenClick(token.name)}
                title={token.description}
              >
                {`{${token.name}}`}
              </button>
            ))}
          </div>
        </div>
        
        <div className="preview-section">
          <h4>ãƒ—ãƒ¬ãƒ“ãƒ¥ãƒ¼</h4>
          <div className="preview-box">
            <span className="preview-text">{preview || 'ãƒ—ãƒ¬ãƒ“ãƒ¥ãƒ¼ã‚’ç”Ÿæˆä¸­...'}</span>
            <span className="extension">.mp4</span>
          </div>
        </div>
      </div>
      
      <div className="custom-rules-section">
        <h3>ã‚«ã‚¹ã‚¿ãƒ æŠ½å‡ºãƒ«ãƒ¼ãƒ«</h3>
        <div className="rules-list">
          {customRules.map((rule, index) => (
            <CustomRuleEditor
              key={rule.id}
              rule={rule}
              onChange={(updated) => updateRule(index, updated)}
              onDelete={() => deleteRule(index)}
            />
          ))}
        </div>
        <button onClick={handleAddCustomRule}>
          + æ–°ã—ã„ãƒ«ãƒ¼ãƒ«ã‚’è¿½åŠ 
        </button>
      </div>
      
      <div className="tips-section">
        <h4>ğŸ’¡ ãƒ’ãƒ³ãƒˆ</h4>
        <ul>
          <li>æ¡ä»¶ä»˜ããƒˆãƒ¼ã‚¯ãƒ³: {`{?quality:{quality}_}?`} - qualityãŒå­˜åœ¨ã™ã‚‹å ´åˆã®ã¿è¡¨ç¤º</li>
          <li>æ—¥ä»˜ãƒ•ã‚©ãƒ¼ãƒãƒƒãƒˆ: {`{date}`} ã§YYYY-MM-DDå½¢å¼</li>
          <li>é€£ç•ª: {`{index}`} ã§è‡ªå‹•çš„ã«ç•ªå·ä»˜ã‘</li>
        </ul>
      </div>
      
      <div className="actions">
        <button onClick={() => onSave(template, customRules)}>
          ä¿å­˜
        </button>
      </div>
    </div>
  );
};
```

## 6. ã‚µã‚¤ãƒˆåˆ¥è¨­å®š

### 6.1 ãƒ—ãƒªã‚»ãƒƒãƒˆå®šç¾©

```typescript
// ãƒ‡ãƒ•ã‚©ãƒ«ãƒˆã®ã‚µã‚¤ãƒˆåˆ¥ãƒ«ãƒ¼ãƒ«
const SITE_PRESETS: SitePreset[] = [
  {
    name: 'YouTube',
    pattern: /youtube\.com|youtu\.be/,
    template: '{channel}-{title}-{quality}-{date}',
    tokens: [
      { name: 'channel', selector: 'ytd-channel-name a' },
      { name: 'views', selector: '.view-count', regex: /([0-9,]+)/ },
      { name: 'likes', selector: '[aria-label*="like"]', regex: /([0-9,]+)/ },
    ]
  },
  {
    name: 'Vimeo',
    pattern: /vimeo\.com/,
    template: '{channel}-{title}-{quality}',
    tokens: [
      { name: 'channel', selector: '.byline a' },
      { name: 'plays', selector: '.plays', regex: /([0-9,]+)/ },
    ]
  },
  {
    name: 'Twitch',
    pattern: /twitch\.tv/,
    template: '{channel}-{title}-{date}-{time}',
    tokens: [
      { name: 'channel', selector: '.channel-header__user' },
      { name: 'game', selector: '[data-a-target="stream-game-link"]' },
    ]
  },
  {
    name: 'Generic',
    pattern: /.*/,
    template: '{site}-{title}-{date}',
    tokens: []
  }
];
```

## 7. ã‚¨ã‚¯ã‚¹ãƒãƒ¼ãƒˆ/ã‚¤ãƒ³ãƒãƒ¼ãƒˆ

### 7.1 è¨­å®šã®ã‚¨ã‚¯ã‚¹ãƒãƒ¼ãƒˆ

```typescript
interface SmartNamingExport {
  version: string;
  templates: {
    default: string;
    sites: Array<{
      pattern: string;
      template: string;
    }>;
  };
  customTokens: CustomToken[];
  createdAt: string;
}

// ã‚¨ã‚¯ã‚¹ãƒãƒ¼ãƒˆå‡¦ç†
async function exportSettings(): Promise<string> {
  const settings = await db.getSmartNamingSettings();
  const exportData: SmartNamingExport = {
    version: '1.0.0',
    templates: settings.templates,
    customTokens: settings.customTokens,
    createdAt: new Date().toISOString(),
  };
  
  return JSON.stringify(exportData, null, 2);
}

// ã‚¤ãƒ³ãƒãƒ¼ãƒˆå‡¦ç†
async function importSettings(jsonString: string): Promise<void> {
  const data: SmartNamingExport = JSON.parse(jsonString);
  
  // ãƒãƒ¼ã‚¸ãƒ§ãƒ³äº’æ›æ€§ãƒã‚§ãƒƒã‚¯
  if (!isCompatibleVersion(data.version)) {
    throw new Error(`Incompatible version: ${data.version}`);
  }
  
  // ãƒãƒªãƒ‡ãƒ¼ã‚·ãƒ§ãƒ³
  validateImportData(data);
  
  // è¨­å®šã®é©ç”¨
  await db.saveSmartNamingSettings({
    templates: data.templates,
    customTokens: data.customTokens,
  });
}
```

## 8. ãƒˆãƒ©ãƒ–ãƒ«ã‚·ãƒ¥ãƒ¼ãƒ†ã‚£ãƒ³ã‚°

### 8.1 ä¸€èˆ¬çš„ãªå•é¡Œã¨è§£æ±ºç­–

| å•é¡Œ | åŸå›  | è§£æ±ºç­– |
|------|------|--------|
| ãƒˆãƒ¼ã‚¯ãƒ³ãŒç½®æ›ã•ã‚Œãªã„ | ã‚»ãƒ¬ã‚¯ã‚¿ãŒæ­£ã—ããªã„ | é–‹ç™ºè€…ãƒ„ãƒ¼ãƒ«ã§ã‚»ãƒ¬ã‚¯ã‚¿ã‚’ç¢ºèª |
| ãƒ•ã‚¡ã‚¤ãƒ«åãŒé•·ã™ãã‚‹ | ãƒ†ãƒ³ãƒ—ãƒ¬ãƒ¼ãƒˆãŒè¤‡é›‘ | ä¸è¦ãªãƒˆãƒ¼ã‚¯ãƒ³ã‚’å‰Šé™¤ |
| é‡è¤‡ãƒ•ã‚¡ã‚¤ãƒ«å | åŒã˜åå‰ã®ç”Ÿæˆ | {timestamp}ã‚„{uuid}ã‚’è¿½åŠ  |
| æ–‡å­—åŒ–ã‘ | ã‚¨ãƒ³ã‚³ãƒ¼ãƒ‡ã‚£ãƒ³ã‚°å•é¡Œ | UTF-8ã‚’ç¢ºå®Ÿã«ä½¿ç”¨ |

### 8.2 ãƒ‡ãƒãƒƒã‚°ãƒ¢ãƒ¼ãƒ‰

```typescript
// ãƒ‡ãƒãƒƒã‚°æƒ…å ±ã®å‡ºåŠ›
class SmartNamingDebugger {
  static logExtraction(tokens: Record<string, string>): void {
    console.group('Smart Naming: Token Extraction');
    console.table(tokens);
    console.groupEnd();
  }
  
  static logTemplate(template: string, result: string): void {
    console.group('Smart Naming: Template Processing');
    console.log('Template:', template);
    console.log('Result:', result);
    console.groupEnd();
  }
  
  static logSanitization(before: string, after: string): void {
    console.group('Smart Naming: Sanitization');
    console.log('Before:', before);
    console.log('After:', after);
    console.groupEnd();
  }
}